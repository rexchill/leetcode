package main

// T122:买卖股票的最佳时机II
// 贪心
func maxProfit2(prices []int) int {
	ans := 0
	// [1,2,3,4,5]=>1买入，5卖出<=>区间大小为1，上升区间的左端点买入，右端点卖出，即上升区间的差值就是利润
	for i := 1; i < len(prices); i++ {
		if prices[i]-prices[i-1] > 0 {
			ans += prices[i] - prices[i-1]
		}
	}
	return ans
}

// DP
func maxProfit2_2(prices []int) int {
	n := len(prices)
	// dp[i][0]表示第i天结束时不持有股票的利润，dp[i][1]表示第i天结束时还持有股票的利润
	dp := make([][2]int, n)

	// 初始化；第0天只能买，不能卖
	// 第0天，不持有股票，利润为0
	dp[0][0] = 0
	// 第0天，持有股票，只能是第0天买入的这一支股票
	dp[0][1] = -prices[0]

	// 开始dp，先考虑卖，再考虑买
	for i := 1; i < n; i++ {
		// 当天不持有股票的情况；要么等于前一天不持有股票的利润，要么等于前一天持有股票加上当天卖出得到的利润
		dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])

		// 当天持有股票的情况；要么等于前一天也持有股票的利润，要么等于前一条不持有股票加上当天买入得到的利润
		dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
	}

	// 对于为什么不是dp[n-1][0]和dp[n-1][1]+prices[n-1]取最大的问题：
	// 最后一天，dp[n-1][1]要么 ①是前一天的dp中的股票没有卖，要么 ②是前一天dp中的股票卖了，又买了当天的股票
	// 而对于 ①前一天的dp中的股票没有卖，选择在最后一天卖的情况已经包含在dp[n-1][0]中了
	// 对于 ②前一天dp中的股票卖了，又买了当天的股票，这最后一天买入的这支股票已经不能卖出去了，成本没有收回来，肯定值更小
	return dp[n-1][0]
}
